# # Tree Check

# Given a non-empty adjacency list of an undirected graph, `graph`, return whether it is a _tree_. A graph is a tree if it is _acyclic_ and _connected_.

# https://iio-beyond-ctci-images.s3.us-east-1.amazonaws.com/tree-check-1.png

# Example 1:
# graph = [
#   [2],           # Node 0
#   [2, 5],        # Node 1
#   [0, 1, 3, 4],  # Node 2
#   [2],           # Node 3
#   [2],           # Node 4
#   [1]            # Node 5
# ]
# Output: True
# See left graph in the picture above

# Example 2:
# graph = [
#   [2],           # Node 0
#   [5],           # Node 1
#   [0, 3],        # Node 2
#   [2],           # Node 3
#   [],            # Node 4
#   [1]            # Node 5
# ]
# Output: False
# This graph is not connected
# See center graph in the picture above

# Example 3:
# graph = [
#   [1],           # Node 0
#   [0, 2, 5],     # Node 1
#   [1, 3, 4],     # Node 2
#   [2],           # Node 3
#   [2, 5],        # Node 4
#   [1, 4]         # Node 5
# ]
# Output: False
# This graph is not acyclic
# See right graph in the picture above

# Constraints:

# - `1 ≤ graph.length ≤ 1000`
# - `graph[i].length < 1000`
# - `0 ≤ graph[i][j] < graph.length`
# - The adjacency list is properly formatted, with no parallel edges or self-loops

def check_tree(graph: list[list]) -> bool:

    visited = set()

    def dfs_detect_cycle(node, parent_node):

        if node in visited:
            #base condition
            return True
        else:
            visited.add(node)

        for neighbor_node in graph[node]:
            if neighbor_node not in visited and neighbor_node != parent_node:
                if dfs_detect_cycle(neighbor_node, node):
                    return True
        return False

    # detect cycle
    if dfs_detect_cycle(0, None):
        return False

    return len(visited) == len(graph) #check if graph is connected/not